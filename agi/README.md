# AGI v0.1

```
agi/
├── README.md
├── pyproject.toml
├── src/
│   ├── core/
│   │   ├── orchestrator.py
│   │   ├── world_model.py
│   │   ├── planner.py
│   │   ├── critic.py
│   │   ├── memory.py
│   │   └── tools/
│   │       ├── python_runner.py
│   │       ├── calculator.py
│   │       ├── retrieval.py
│   │       └── sim_physics.py
│   ├── governance/
│   │   ├── policy.yaml
│   │   └── gatekeeper.py
│   └── evals/
│       ├── harness.py
│       └── tasks/
│           ├── math_small.jsonl
│           ├── planning_small.jsonl
│           └── sim_causal.jsonl
├── notebooks/
├── artifacts/
└── tests/
    ├── test_memory.py
    ├── test_planner_contract.py
    └── test_tools_contract.py
```

## Getting Started

Create and activate a virtual environment, then install dependencies:

```bash
python -m venv .venv
source .venv/bin/activate
pip install -e .[dev]
```

Run the full test suite:

```bash
pytest
```

Run the evaluation harness:

```bash
python -m agi.src.evals.harness
```

Artifacts generated by the agent are stored under `artifacts/` with run manifests.

## Memory configuration

The memory system pairs a persistent episodic store with a short-lived working
cache. During orchestration the planner receives summaries sourced from the
working set, while tools can issue focused retrievals from the episodic corpus to
recover richer history.

### Components and orchestration flow

When memory is enabled the orchestration loop wires both components together:

1. **Hydrate working memory** – the orchestrator preloads recent episodic entries
   matching the goal's claim IDs and the tools referenced in the proposed plans.
2. **Execute plan steps** – each tool invocation receives the working-memory
   slice aligned with the tool alongside a handle to the episodic store for
   deeper lookups.
3. **Commit significant episodes** – successful or information-rich results are
   appended to episodic memory and mirrored into the working cache for future
   steps.

The approach mirrors the behaviour exercised by the multi-turn tests under
`agi/tests/test_orchestrator.py` and `agi/tests/test_tools_contract.py`.

### Enabling or disabling memory

Set `AGI_ENABLE_MEMORY` to control whether working/episodic memory is engaged:

```bash
# enable memory (default)
export AGI_ENABLE_MEMORY=1

# disable memory hydration and storage
export AGI_ENABLE_MEMORY=0
```

With the flag enabled, working memory keeps the most recent episodes per tool and
shares that context with each tool invocation via the `RunContext`. Tools can
also query the episodic store directly through `RunContext.recall_from_episodic()`
which supports simple text filtering.

Leaving the variable unset retains the default (memory enabled). Setting the flag
to a falsy value skips both working-memory hydration and episodic commits so tool
invocations operate without prior context.

### Validating recall behaviour

Run the memory-focused integration tests to verify the orchestrator commits
episodes and the retrieval tool surfaces relevant history:

```bash
pytest agi/tests/test_orchestrator.py::test_orchestrator_hydrates_working_memory \
       agi/tests/test_tools_contract.py::test_retrieval_tool_filters_memory
```

