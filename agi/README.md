# AGI v0.1

```
agi/
├── README.md
├── pyproject.toml
├── src/
│   ├── core/
│   │   ├── orchestrator.py
│   │   ├── world_model.py
│   │   ├── planner.py
│   │   ├── critic.py
│   │   ├── memory.py
│   │   └── tools/
│   │       ├── python_runner.py
│   │       ├── calculator.py
│   │       ├── retrieval.py
│   │       └── sim_physics.py
│   ├── governance/
│   │   ├── policy.yaml
│   │   └── gatekeeper.py
│   └── evals/
│       ├── harness.py
│       └── tasks/
│           ├── math_small.jsonl
│           ├── planning_small.jsonl
│           └── sim_causal.jsonl
├── notebooks/
├── artifacts/
└── tests/
    ├── test_memory.py
    ├── test_planner_contract.py
    └── test_tools_contract.py
```

## Getting Started

Create and activate a virtual environment, then install dependencies:

```bash
python -m venv .venv
source .venv/bin/activate
pip install -e .[dev]
```

Run the full test suite:

```bash
pytest
```

Run the evaluation harness:

```bash
python -m agi.src.evals.harness
```

Artifacts generated by the agent are stored under `artifacts/` with run manifests.

## Memory subsystem

AGI can operate with an optional memory system that threads context across
reasoning steps. When enabled it tracks information in two complementary tiers:

* **Working memory** is a per-run cache that keeps the most recent episodes
  close to the next tool invocation so calculations can reuse intermediate
  results without re-querying the broader store.
* **Episodic memory** is a persistent log of noteworthy tool executions. It
  survives across runs and acts as the source of truth for recalls that reach
  beyond the working-memory window.

### Execution lifecycle

1. The orchestrator gathers a working-memory snapshot before executing a plan,
   pulling the most relevant episodic entries for the claims and tools involved
   in the upcoming steps.
2. Each tool receives a `RunContext` populated with that working-memory slice
   together with a `recall_from_episodic()` helper so the tool can fetch
   historical episodes on demand. The helper accepts optional `tool`, `limit`,
   and `text_query` parameters so callers can tailor the recall scope.
3. After the tool finishes, the orchestrator promotes the episode back into
   both tiers: the working cache is refreshed immediately and significant
   outputs are committed to the episodic store.

This flow is covered by the multi-turn tests in
`agi/tests/test_orchestrator.py::test_orchestrator_hydrates_working_memory` and
`agi/tests/test_tools_contract.py::test_retrieval_tool_filters_memory`.

### Runtime toggle

Use the `AGI_ENABLE_MEMORY` environment variable to control the behaviour:

```bash
# enable memory (default)
export AGI_ENABLE_MEMORY=1

# disable memory hydration and storage
export AGI_ENABLE_MEMORY=0
```

The default is enabled (`1`). Setting the variable to a falsy value prevents the
orchestrator from hydrating the working cache or committing new episodic
records, yielding stateless tool runs. When memory is disabled the orchestrator
still constructs a valid `RunContext`, but `working_memory` is empty and
`recall_from_episodic()` becomes a no-op.

When left at the defaults the orchestrator persists episodic history to
`<working_dir>/memory.jsonl` (with `working_dir` defaulting to `artifacts/`) and
maintains an in-memory working cache. Supplying custom `MemoryStore` or
`WorkingMemory` instances allows advanced callers to override these defaults
while preserving the hydration pipeline above.

### Validating recall behaviour

Run the focused tests below to exercise the hydration and recall pipeline:

```bash
pytest agi/tests/test_orchestrator.py::test_orchestrator_hydrates_working_memory \
       agi/tests/test_tools_contract.py::test_retrieval_tool_filters_memory
```

