# AGI v0.1

```
agi/
├── README.md
├── pyproject.toml
├── src/
│   ├── core/
│   │   ├── orchestrator.py
│   │   ├── world_model.py
│   │   ├── planner.py
│   │   ├── critic.py
│   │   ├── memory.py
│   │   └── tools/
│   │       ├── python_runner.py
│   │       ├── calculator.py
│   │       ├── retrieval.py
│   │       └── sim_physics.py
│   ├── governance/
│   │   ├── policy.yaml
│   │   └── gatekeeper.py
│   └── evals/
│       ├── harness.py
│       └── tasks/
│           ├── math_small.jsonl
│           ├── planning_small.jsonl
│           └── sim_causal.jsonl
├── notebooks/
├── artifacts/
└── tests/
    ├── test_memory.py
    ├── test_planner_contract.py
    └── test_tools_contract.py
```

## Getting Started

Create and activate a virtual environment, then install dependencies:

```bash
python -m venv .venv
source .venv/bin/activate
pip install -e .[dev]
```

Run the full test suite:

```bash
pytest
```

Run the evaluation harness:

```bash
python -m agi.src.evals.harness
```

Artifacts generated by the agent are stored under `artifacts/` with run manifests.

## Memory configuration

AGI runs can optionally maintain cross-step context through a two-tier memory
system. A persistent **episodic** store records significant tool executions,
while a per-run **working** cache keeps a small window of the most relevant
episodes close to the next reasoning step.

### Orchestration flow

When memory is enabled the orchestrator coordinates both tiers to hydrate the
planner and every tool invocation:

1. **Hydrate working memory** – before executing plans the orchestrator loads
   recent episodic entries that match the goal's claim IDs or the tools named in
   the plan. This snapshot becomes the `RunContext.working_memory` value handed
   to each tool.
2. **Reason with context** – during each tool call the orchestrator supplies the
   tool-specific slice of working memory and exposes the episodic store through
   `RunContext.recall_from_episodic()` so tools can run targeted lookups.
3. **Commit significant episodes** – once a tool returns, successful or
   information-rich outputs are appended to the episodic store and mirrored back
   into the working cache so later steps inherit the fresh context.

This mirrors the multi-turn scenarios in
`agi/tests/test_orchestrator.py::test_orchestrator_hydrates_working_memory` and
`agi/tests/test_tools_contract.py::test_retrieval_tool_filters_memory`.

### Enabling or disabling memory

Control the behaviour with the `AGI_ENABLE_MEMORY` flag:

```bash
# enable memory (default)
export AGI_ENABLE_MEMORY=1

# disable memory hydration and storage
export AGI_ENABLE_MEMORY=0
```

Leaving the flag unset retains the default of `1`. Setting it to a falsy value
skips working-memory hydration and episodic commits so tools execute in a
stateless mode. When enabled, `RunContext.working_memory` exposes the cached
episodes and `RunContext.recall_from_episodic()` provides filtered access to the
full store, including simple substring matching via the `text_query` argument.

### Validating recall behaviour

Run the focused tests to verify the hydration and recall pipeline end-to-end:

```bash
pytest agi/tests/test_orchestrator.py::test_orchestrator_hydrates_working_memory \
       agi/tests/test_tools_contract.py::test_retrieval_tool_filters_memory
```

